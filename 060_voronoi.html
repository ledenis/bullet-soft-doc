<!DOCTYPE html><html><head><meta charset="utf-8"><style>/* Fonts */
@font-face{
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face{
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

/* Body */
html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#4d4d4c;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 30px;
  border: 1px solid #ddd;
  outline: 1300px solid #f8f8f8;
}

/* Links */
a{ color: #06d; text-decoration:none; }
a:hover{ color: #06e; text-decoration: underline; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

::-moz-selection { background:#a8d1ff; color:#000 }
::selection { background:#a8d1ff; color:#000 }

a::-moz-selection { background:#a8d1ff; color:#0645ad }
a::selection { background:#a8d1ff; color:#0645ad }

/* Header Anchor Links*/
.headeranchor-link {
  color:#111;
  border: 0;
  margin-left: -20px;
  padding-right: 6px;
  cursor: pointer;
  position: absolute;
  display: block;
  top: 0;
  left: 0;
  bottom: 0;
}

.headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor-link:hover,
.headeranchor-link:visited,
.headeranchor-link:active
{ text-decoration: none; color:#4d4d4c; }
.headeranchor-link:hover .headeranchor:before,
h1:hover .headeranchor:before,
h2:hover .headeranchor:before,
h3:hover .headeranchor:before,
h4:hover .headeranchor:before,
h5:hover .headeranchor:before,
h6:hover .headeranchor:before
{ content: '\f05c'; }

abbr { cursor: pointer; }

/* Paragraphs */
p { margin:1em 0; }

/* Images */
img {
  max-width:100%;
  border: 0;
  -ms-interpolation-mode: bicubic;
  vertical-align: middle;
}

/* Headers */
h1,h2,h3,h4,h5,h6 {
  font-weight:normal;
  color:#111;
  line-height: 1.7;
  position: relative;
}
h4,h5,h6{ font-weight: bold; }
h1 { font-size:2.5em; border-bottom: 1px solid #ddd;}
h2 { font-size:2em; border-bottom:1px solid #eee; padding-bottom: 5px; }
h3 { font-size:1.5em; }
h4 { font-size:1.2em; }
h5 { font-size:1em; }
h6 { font-size:0.9em; }

/* Block Quotes */
blockquote {
  color:#666666;
  margin:0;
  padding-left: 3em;
  border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }

/* Raw Blocks */
pre, code, kbd, samp {
  color: #000;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  font-size: 0.88em;
  background-color: #F8F8F8;
  border: 1px solid #CCC;
}

pre {
  padding: 10px;
  overflow: auto;
}

code { padding: 0 3px 0 3px; }
pre code { border: 0; padding: 0; }

/* Admonition */
.admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  font-size: 0.88em;
  padding: 0.5em 1em 0.5em 1em;
  margin: 10px auto;
  color: #888888;
  background-color: #F8F8F8;
  border: 1px solid #888888;
}

.admonition p { padding: 0; margin: 0; }
.admonition-title { font-weight: bold; margin: 0; }

.admonition-icon {
  font: normal normal 16px fontawesome-mini;
  line-height: 1.5;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  float: left;
}

.admonition.attention { color: #4F8A10; background-color: #DFF2BF; border: 1px solid #4F8A10; }
.admonition.caution { color: #D63301; background-color: #FFCCBA; border: 1px solid #D63301; }
.admonition.hint { color: #00529B; background-color: #BDE5F8; border: 1px solid #00529B; }
.admonition.danger { color: #D8000C; background-color: #FFBABA; border: 1px solid #D8000C; }
.admonition.question { color: #00049b; background-color: #BDC8F8; border: 1px solid #00049b; }
.admonition.note { color: #9F6000; background-color: #FEEFB3; border: 1px solid #9F6000; }

.attention > .admonition-icon:before { content: "\f058\00a0"; }
.caution > .admonition-icon:before { content: "\f06a\00a0"; }
.hint > .admonition-icon:before { content: "\f05a\00a0"; }
.danger > .admonition-icon:before { content: "\f056\00a0"; }
.question > .admonition-icon:before { content: "\f059\00a0"; }
.note > .admonition-icon:before { content: "\f040\00a0"; }

/* progress bar*/
.progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #F8F8F8;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow:
    1px 1px 0px #fefefe,
    -1px -1px 0px #fefefe,
    -1px 1px 0px #fefefe,
    1px -1px 0px #fefefe,
    0px 1px 0px #fefefe,
    0px -1px 0px #fefefe,
    1px 0px 0px #fefefe,
    -1px 0px 0px #fefefe,
    1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.progress-bar {
  height: 24px;
  float: left;
  border-right: 1px solid #ccc;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #34c2e3;
  box-shadow: inset 0 1px 0px rgba(255, 255, 255, .5);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 53%, rgba(255, 255, 255, .4) 53%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 53%, rgba(255, 255, 255, .4) 53%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 53%, rgba(255, 255, 255, .4) 53%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 53%, rgba(255, 255, 255, .4) 53%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 53%, rgba(255, 255, 255, .4) 53%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.progress-100plus .progress-bar { background-color: #1ee038; }
.progress-80plus .progress-bar { background-color: #86e01e; }
.progress-60plus .progress-bar { background-color: #f2d31b; }
.progress-40plus .progress-bar { background-color: #f2b01e; }
.progress-20plus .progress-bar { background-color: #f27011; }
.progress-0plus .progress-bar { background-color: #f63a0f; }

.gloss .progress-bar {
  box-shadow:
    inset -1px 1px 0px rgba(255, 255, 255, .5),
    inset 0 -4px 12px rgba(255, 255, 255, .7),
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0px rgba(0, 0, 0, .05),
    inset 1px -1px 0px rgba(255, 255, 255, .2);
}

.candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes { 0% { background-position: 0 0; } 100% { background-position: 60px 0; } }
@-moz-keyframes animate-stripes { 0% { background-position: 0 0; } 100% { background-position: 60px 0; } }
@keyframes animate-stripes { 0% { background-position: 0 0; } 100% { background-position: 60px 0; } }

/* Inlines */
b, strong { font-weight: bold; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

dfn { font-style: italic; }

/* Lists */
ul, ol { padding-left: 30px; }
li p:last-child { margin:0 }
.task-list-item { list-style-type: none; }
.task-list-item input { float:left; margin-left: -20px; margin-top: 6px; }
dt { font-weight: bold; font-style: italic;}
dd { margin: 0 0 0 2em; }

/* Tables */
table { width: 100%; border-collapse: collapse; overflow-x: auto; overflow-y: hidden; display: block;}
table tr { background-color: #fefefe; }
table tr:nth-child(2n) { background-color: #f8f8f8; }
td, th { border: 1px solid #ddd; padding: 6px 13px; }

/* Codehilite Tables */
.codehilitetable { border: 0; border-spacing: 0; }
.linenos, .code, .codehilitetable td { border: 0; padding: 0; }
td:not(.linenos) .linenodiv { padding: 0 !important; }
.code { width: 100%; }
.linenos div pre, .linenodiv pre {
  border: 0;
  border-top: 1px solid #CCC;
  border-left: 1px solid #CCC;
  border-right: 1px solid #CCC;
  border-bottom: 1px solid #CCC;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.code div pre {
  border: 0;
  border-top: 1px solid #CCC;
  border-right: 1px solid #CCC;
  border-bottom: 1px solid #CCC;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

/* Media */
@media only screen and (min-width: 480px) {
  body{ font-size:14px; }
}

@media only screen and (min-width: 768px) {
  body{ font-size:16px; }
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{ font-size:12pt; max-width:100%; outline:none; border: 0;}
  a, a:visited { text-decoration: underline; }
  .headeranchor-link { display: none; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  .progress, .progress-bar { box-shadow: none; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>060_voronoi</title></head><body><h1 id="voronoi-fracture-and-destruction"><a name="user-content-voronoi-fracture-and-destruction" href="#voronoi-fracture-and-destruction" class="headeranchor-link"  aria-hidden="true"><span class="headeranchor"></span></a>Voronoi Fracture and Destruction</h1>
<p>To simulate the destruction of an object in 2D or 3D, an algorithm called <em>Voronoi fracturing</em> (or shattering) exists. It uses a mathematical concept called <em>Voronoi diagram</em>, hence its name. A Voronoi diagram describes the partitioning of the space from a set of points into regions, called <em>cells</em>. The cells are guaranteed to be convex and no overlapped, and will be the shards of the fracture. You can see a representation in 2D below.</p>
<p><img alt="A Voronoi diagram" src="img/voronoi/01_voronoi-diagram.png" /></p>
<p>(<a href="http://mathworld.wolfram.com/VoronoiDiagram.html">Source</a>)</p>
<p>In this chapter, the algorithm is explained, along with the code, which comes from the demos of Bullet Physics.</p>
<h2 id="the-approach"><a name="user-content-the-approach" href="#the-approach" class="headeranchor-link"  aria-hidden="true"><span class="headeranchor"></span></a>The approach</h2>
<p>The algorithm works using 3D planes. From a 3D mesh, it takes the faces (triangles) and turn them into planes, represented by their equations. The idea is as follows: each shard (cell) is created by taking a Voronoi point, then create more planes, located at half distance between this current point and other ones, in order to generate the boundaries of this cell. The process is repeated for each point.</p>
<p>The pseudo code is shown below (adapted from the <a href="http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=7707">forum post</a> of the demo author).</p>
<pre><code>planes = collection of source object faces represented as plane equations
foreach current_point in voronoi_cell_points
    copy planes
    foreach other sorted_point by distance from current_point
        if distance &gt; max_distance
            break # rest of sorted points too far, we&rsquo;re done with this current_point
        add new plane to planes, normal and distance = -(sorted_point - current_point) / 2
        collect vertices (3-plane intersections) by planes that fall inside all planes only
        delete planes that fell outside
        max_distance = (furthest vertex from current_point) * 2
    we now have vertices and/by planes for one voronoi 3D shard,
    process vertices by plane (sort counter-clockwise, etc.) to get faces and edges</code></pre>
<p>A 2D representation of the algorithm at the end of one iteration is shown below. A shard is generated and is represented by the white area. The red point is the current_point, the black ones are the other Voronoi points which are sorted, the black and red lines represent the planes. The blue points represent the vertices at planes intersections.</p>
<p><img alt="" src="img/voronoi/02_intersection-done.png" />      </p>
<p>This is a brute force method because it considers all Voronoi points, not only the neighbours. Another approach is to compute the Delaunay tetrahedralization, which connects points with tetrahedrons. From it, the Voronoi diagram can be extracted, since it is its dual graph. But the method detailed here does not use Delaunay tetrahedralization.</p>
<h2 id="the-implementation"><a name="user-content-the-implementation" href="#the-implementation" class="headeranchor-link"  aria-hidden="true"><span class="headeranchor"></span></a>The implementation</h2>
<p>The implementation is adapted from the <em>VoronoiFractureDemo.cpp</em> source code. Assuming that the source mesh and the random Voronoi points are initialized, we begin with creating a function, <code>voronoiMeshShatter()</code>, that takes as arguments the points, the mesh (defined by vertices and triangles indices), its position and rotation. The 2 other parameters here (the density and the world, as a cutom class) are not important for the shattering algorithm.</p>
<pre><code>void Voronoi::voronoiMeshShatter(
        const btAlignedObjectArray&lt;btVector3&gt;&amp; srcPoints,
        const btAlignedObjectArray&lt;btVector3&gt;&amp; verts, const btAlignedObjectArray&lt;int&gt;&amp; indices,
        const btQuaternion&amp; rot, const btVector3&amp; pos,
        btScalar matDensity, World&amp; world) {
    // srcPoints define voronoi cells in local space (avoid duplicates)
    // verts = source mesh vertices in local space
    // indices = source mesh vertices indices composing each triangle
    // rot &amp; pos = source mesh quaternion rotation and translation
    // matDensity = Material density for voronoi shard mass calculation

    //&hellip;
}</code></pre>
<p>Meshes are generally described in local space (the origin is at the center of its vertices), as it is the case here. THe points are also in local space. We will convert them to world space.</p>
<pre><code>// Convert verts to world space
int numverts = verts.size();
chverts.resize(numverts);
for (i=0; i &lt; numverts; i++) {
    chverts[i] = quatRotate(rot, verts[i]) + pos;
}

// Convert points to world space
int numpoints = srcPoints.size();
points.resize(numpoints);
for (i=0; i &lt; numpoints; i++) {
    points[i] = quatRotate(rot, srcPoints[i]) + pos;
}
sortedVoronoiPoints.copyFromArray(points);
</code></pre>
<h3 id="plane-representation"><a name="user-content-plane-representation" href="#plane-representation" class="headeranchor-link"  aria-hidden="true"><span class="headeranchor"></span></a>Plane representation</h3>
<p>We need to get the planes formed by the faces of the mesh. But how to represent a plane? It can be seen as an cartesian equation <code>ax + by + cz = d</code> where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are the 4 parameters. The vector <em>(a, b, c)</em> represent the <em>normal</em>, the scalar <em>d</em> represents the <em>distance</em>. These values can be stored in the Bullet&rsquo;s <code>btVector3</code>, which has a &ldquo;hidden&rdquo; 4th value that can be accessed with the <code>[]</code> operator, like this: <code>v[3]</code>.</p>
<p>Since the mesh is composed of triangles, the planes can be found using some geometry. If <code>v0</code>, <code>v1</code>, <code>v2</code> are the corner vertices of a triangle, the formulas in pseudo-code:</p>
<pre><code>normal   = ( (v1 - v0).cross(v2 - v0) ).normalize();
distance = normal.dot(v0);
</code></pre>
<p>The actual code is:</p>
<pre><code>// Get convexPlanes from triangles
int v0, v1, v2; // vertices
for (i=0; i &lt; indices.size();) {
    v0 = indices[i++];
    v1 = indices[i++];
    v2 = indices[i++];
    // plane: 4 values stored in btVector3, as equation ax + by + cz = d
    // (4th value accessed as plane[3])
    plane = (chverts[v1]-chverts[v0]).cross(chverts[v2]-chverts[v0]).normalize();
    plane[3] = plane.dot(chverts[v0]);
    convexPlanes.push_back(plane);
}
</code></pre>
<h3 id="loop"><a name="user-content-loop" href="#loop" class="headeranchor-link"  aria-hidden="true"><span class="headeranchor"></span></a>Loop</h3>
<p>We that the mesh and points are prepared, we can start to create the cells. To do this, the Voronoi points are taken one by one with a loop. </p>
<pre><code>// For each voronoi point
for (i=0; i &lt; numpoints; i++) {
    curVoronoiPoint = points[i];

    //&hellip;
}</code></pre>
<p>During the iteration, we will loop over the other points, sorted by the distance to the current point. Thus, we start with the point that is the nearest, then go to the next nearest, and so on. We stop when the distance to the next point is greater than a limit. But before that, we will make the calculations of the planes distances easier by shifting the their equations relatively to the current point.</p>
<pre><code>planes.copyFromArray(convexPlanes);
// Shift all planes relative to current point
for (j=0; j &lt; numconvexPlanes; j++) {
    planes[j][3] -= planes[j].dot(curVoronoiPoint);
}
</code></pre>
<p>And we sort the points by distance.</p>
<pre><code>maxDistance = SIMD_INFINITY;

// Sort all points by distance from current point
sortedVoronoiPoints.heapSort(pointCmp());
</code></pre>
<p>The comparator <code>pointCmp()</code> must be defined elsewhere. Note that <code>curVoronoiPoint</code> also need to be declared outside in order to be accessed from this comparator&rsquo;s scope.</p>
<pre><code>static btVector3 curVoronoiPoint;

// Comparator to sort planes by distance from curVoronoiPoint
struct pointCmp
{
    bool operator()(const btVector3&amp; p1, const btVector3&amp; p2) const
    {
        float v1 = (p1-curVoronoiPoint).length2();
        float v2 = (p2-curVoronoiPoint).length2();
        bool result0 = v1 &lt; v2;
        return result0;
    }
};
</code></pre>
<p>Back to the <code>voronoiMeshShatter()</code> function, we can now iterate through the other points, in order to generate a plane at half way between the current and the other point. At the same time we can check the distance limit. If this limit is reached for this point, it is for the next because the points are sorted.</p>
<pre><code>for (j=1; j &lt; numpoints; j++) {
    // Create plane at half distance from current and other point
    normal = sortedVoronoiPoints[j] - curVoronoiPoint;
    nlength = normal.length();

    if (nlength &gt; maxDistance) // quit if point is too far
        break;

    plane = normal.normalized();
    plane[3] = nlength / btScalar(2.);
    planes.push_back(plane);
</code></pre>
<p>With this new plane, we generate the points at the intersection of 3 planes.</p>
<pre><code>    // Get vertices by 3 planes intersection, inside all planes
    getVerticesInsidePlanes(planes, vertices, planeIndices);
    if (vertices.size() == 0)
        break;
    numplaneIndices = planeIndices.size();
</code></pre>
<p>The helper function <code>getVerticesInsidePlanes()</code> is used. It takes the <code>planes</code> as <em>in</em> parameters and <code>vertices</code> and <code>planeIndices</code> as <em>out</em> parameters. <code>vertices</code> are the intersections of 3 planes and which are on the &ldquo;right&rdquo; side. <code>planeIndices</code> are the indices of the planes that gave the <code>vertices</code>. The definition of the function is provided below.</p>
<pre><code> void Voronoi::getVerticesInsidePlanes(const btAlignedObjectArray&lt;btVector3&gt;&amp; planes,
        btAlignedObjectArray&lt;btVector3&gt;&amp; verticesOut,
        std::set&lt;int&gt;&amp; planeIndicesOut)
{
    // Based on btGeometryUtil.cpp (Gino van den Bergen / Erwin Coumans)
    verticesOut.resize(0);
    planeIndicesOut.clear();
    const int numPlanes = planes.size();
    int i, j, k, l;
    for (i=0;i&lt;numPlanes;i++)
    {
        const btVector3&amp; N1 = planes[i];
        for (j=i+1;j&lt;numPlanes;j++)
        {
            const btVector3&amp; N2 = planes[j];
            btVector3 n1n2 = N1.cross(N2);
            if (n1n2.length2() &gt; btScalar(0.0001))
            {
                for (k=j+1;k&lt;numPlanes;k++)
                {
                    const btVector3&amp; N3 = planes[k];
                    btVector3 n2n3 = N2.cross(N3);
                    btVector3 n3n1 = N3.cross(N1);
                    if ((n2n3.length2() &gt; btScalar(0.0001)) &amp;&amp; 
                            (n3n1.length2() &gt; btScalar(0.0001) ))
                    {
                        btScalar quotient = (N1.dot(n2n3));
                        if (btFabs(quotient) &gt; btScalar(0.0001))
                        {
                            btVector3 potentialVertex = 
                                    (n2n3 * N1[3] + n3n1 * N2[3] + n1n2 * N3[3]) * 
                                    (btScalar(1.) / quotient);
                            for (l=0; l&lt;numPlanes; l++)
                            {
                                const btVector3&amp; NP = planes[l];
                                if (btScalar(NP.dot(potentialVertex))-btScalar(NP[3]) &gt; 
                                        btScalar(0.000001))
                                    break;
                            }
                            if (l == numPlanes)
                            {
                                // vertex (three plane intersection) inside all planes
                                verticesOut.push_back(potentialVertex);
                                planeIndicesOut.insert(i);
                                planeIndicesOut.insert(j);
                                planeIndicesOut.insert(k);
                            }
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
<hr />
<hr />
<p>(Notes)</p>
<p>Blog posts, use Delaunay<br />
<a href="http://www.joesfer.com/?p=60">http://www.joesfer.com/?p=60</a><br />
<a href="http://www.joesfer.com/?p=69">http://www.joesfer.com/?p=69</a></p>
<p>Volume Sampler<br />
    Seed points<br />
Splitting<br />
    Mesh cuts<br />
Hole filling<br />
    New faces</p>
<h2 id="voronoi-diagrams"><a name="user-content-voronoi-diagrams" href="#voronoi-diagrams" class="headeranchor-link"  aria-hidden="true"><span class="headeranchor"></span></a>Voronoi Diagrams</h2>
<p>Cells for each point</p>
<p>By using Delaunay Tetrahedralization<br />
    Dual graph of Voronoi graph<br />
    Tetrahedra whose corners are the Voronoi points</p>
<p>Then easily get voronoi diagram from it<br />
    Fragments are intersection between mesh and planes</p>
<pre><code>For each voronoi cell C do 
    For each face F in C do 
        Obtain the plane P containing F 
        Split the geometry in two using P, and discard all the polygons on the front side of P 
        Identify the set of vertices lying exactly on P, and generate  a new set of faces filling the hole. 
    end 
end
</code></pre>
<h2 id="demo-brute-force-method"><a name="user-content-demo-brute-force-method" href="#demo-brute-force-method" class="headeranchor-link"  aria-hidden="true"><span class="headeranchor"></span></a>Demo, Brute force method</h2>
<p><a href="http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=7707">http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=7707</a></p>
<p>planes = collection of source convex object faces represented as plane equations<br />
foreach current_point in voronoi_cell_points<br />
    copy planes<br />
    max_distance = (furthest vertex from current_point) * 2 // NOT THERE<br />
    foreach other sorted_point by distance from current_point<br />
        if distance &gt; max_distance<br />
            break # rest of sorted points too far, we&rsquo;re done with this current point<br />
        add new plane to planes, normal and distance = -(sorted_point - current_point) / 2<br />
        collect vertices (3-plane intersections) by planes that fall inside all planes only<br />
        delete planes that fell outside<br />
        max_distance = (furthest vertex from current_point) * 2<br />
    we now have vertices and/by planes for one voronoi 3D shard,<br />
    process vertices by plane (sort counter-clockwise, etc.) to get faces and edges</p>
<p>Demo code</p>
<p>voronoiConvexHullShatter()</p>
<pre><code>For each Voronoi points

    Sort all points by distance to current point

    For each other Voronoi points

        If distance &gt; max_distance
            break

        vertices, planeIndices = getVerticesInsidePlanes(planes) {

            For each plane i
                For each plane j (from i+1)

                    if i, j non colinear
                        For each plane k (from j+1)
                            if j,k and k,i non colinear
                                if quotient? non zero
                                    calculate potential vertex
                                    if potential vertex inside all planes
                                        store potential vertex and the 3 intersecting planes (i,j,k)

        }

        if planeIndices not cover all existing planes
</code></pre>
<p>(end notes)</p></body></html>